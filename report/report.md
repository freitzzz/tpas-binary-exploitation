# Binary Exploitation of Figlet Unix Binary

The present report, written in the context of TPAS (Teoria e Prática de Ataques de Segurança) curricular unit at FCUP (Faculdade de Ciências da Universidade do Porto), aims at describing the process of attempting to find bugs and crashes in a command-line binary for Unix-like systems.
It will start by describing the goals of the project, methodologies being followed, approaches to take and technologies to look on. Then, it will be presented the binary in context of analysis, depicting initial weakness and the reasons to why it was chosen as the target binary. Following this, the working environment and tools used for exploitation will be described in detail, focusing on the quirks and constraints felt during the setup phase. The fourth chapter describes the fuzzing process and achieved results in an iterative manner. To conclude, some final remarks and overall achievements will be presented and discussed.
To conclude, an overview of the overall effectiveness and complexity of performing such analysis will be presented, as well as some remarks for future work.

## 1. Terminologies, Methodologies, Technologies and Goals

Binary exploitation can be defined as the process of "finding a vulnerability in the program and exploiting it to gain control of a shell or modifying the program's functions" [1].
To gain control of a shell, typically newbie attackers inject shellcode in the program through an input stream (e.g., user input(stdin)), which allows for arbitrary code execution (i.e., using a program as the interpreter of crafted binary code). Shellcode is a special type of code produced with assembly instructions, for a specific CPU architecture [2].

Despite shellcode attacks still being popular and effective for a wide range of use cases, more advanced attackers rely on *Return Oriented Programming* (ROP), a technique that exploits the program call stack by hijacking the memory and aligning the assembly instructions present on it to execute code in an arbitrary way [3].
This technique is way more effective on modern age binaries, as these are protected with specific security flags on compile time (e.g., NX, ASLR, Stack Canary) that detect if whether a program was compromised or not during runtime, via a memory corruption [3].

**But how do attackers find vulnerabilities that allow arbitrary code execution?**

To craft code and execute it in a target program, we first need to load it in the program memory so it can be arbitrarily triggered and executed by the program. Since modern operating systems reserve specific memory spaces for a program, no entity can write to this memory in an external manner. So, to write in the program memory, it is needed to *conduct the program to do it so*. This is where the vulnerabilities take place: there is a need to find usage of unsafe operations in a binary, so that specific input or program flow can corrupt the reserved memory. Classic vulnerabilities include:

- **Buffer Overflow**, where data bigger than the actual buffer (i.e., memory space) is written to it, which causes this data to be propagated in the memory, until a crash occurs [4];
- **Use After Free (UAF)**, which occurs when a specific chunk of memory is used after it was deallocated/freed [4, 5];
- **Format Strings**, which occurs when programs that use operations that rely on format strings (e.g., `printf` and `sprintf`) are vulnerable to format operations injection, which will force format strings functions to look for arguments to replace on the format position [4, 5].

```
char buf[8];

void vulnerable() {
    gets(buf);
}
```

Code Snippet 1 - Example of a buffer overflow. The `gets` function does not check for the buffer length, so any input greater than **8**, will cause a buffer overflow.

One very important thing to note, is that memory corruptions are far more easy to occur in "low level" programming languages such as `C` and `C++`, rather in high level ones (e.g., `Javascript, C#`), as the former allows for direct dynamic memory allocation and does not have memory optimizers, such as *garbage collection*. This gives an hint on the programs to choose for trying to find memory vulnerabilities.

## 1.1 What is Fuzzing?

Similar to property based testing. its automatic (which is great)

### References

[1] CTF101, ‘Overview - CTF 101: Binary Exploitation’, CTF101, 2019 https://ctf101.org/binary-exploitation/overview/(accessed Feb. 8, 2022).

[2] Firewalls.com, ‘Shellcode - Firewalls.com’, Firewalls.com, 2022 https://www.firewalls.com/blog/security-terms/shellcode/#:~:text=Shellcode%20is%20a%20special%20type,control%20of%20the%20affected%20system.(accessed Feb. 8, 2022).

[3] Jonathan Salwan, ‘An introduction to the Return Oriented Programming and ROP chain generation’, 2014 http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf(accessed Feb. 8, 2022).

[4] CTF101, ‘Heap Exploitation - CTF 101’, CTF101, 2019 https://ctf101.org/binary-exploitation/heap-exploitation/(accessed Feb. 8, 2022).

[5] CS161, ‘Memory Safety Vulnerabilities | Computer Security’, textbook.cs161.org, 2022 https://textbook.cs161.org/memory-safety/vulnerabilities.html(accessed Feb. 8, 2022).

[<ref_number>] <author>, ‘<title>’, <website_name>, <published_date>. <website_url>(accessed <month>. <day>, <year>).